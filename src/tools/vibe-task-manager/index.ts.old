import { z } from 'zod';
import { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { OpenRouterConfig } from '../../types/workflow.js';
import { registerTool, ToolDefinition, ToolExecutor, ToolExecutionContext } from '../../services/routing/toolRegistry.js';
import logger from '../../logger.js';
import { jobManager } from '../../services/job-manager/index.js';
import path from 'path';

// REMOVED HANGING IMPORTS:
// import { getBaseOutputDir, getVibeTaskManagerOutputDir, getVibeTaskManagerConfig } from './utils/config-loader.js';
// import { getTimeoutManager } from './utils/timeout-manager.js';
// import { AgentOrchestrator } from './services/agent-orchestrator.js';
// import { ProjectOperations } from './core/operations/project-operations.js';
// import { DecompositionService } from './services/decomposition-service.js';
// import { CommandGateway } from './nl/command-gateway.js';
// import fs from 'fs/promises';
// import { AtomicTask } from './types/task.js';
// import { ProjectContext } from './types/project-context.js';
// import { ProjectContext as AtomicProjectContext } from './core/atomic-detector.js';

// Input schema for the Vibe Task Manager tool
const vibeTaskManagerInputSchema = z.object({
  command: z.enum(['create', 'list', 'run', 'status', 'refine', 'decompose']).optional().describe('The command to execute (optional for natural language input)'),
  projectName: z.string().optional().describe('Name of the project to work with'),
  taskId: z.string().optional().describe('ID of the task to work with'),
  description: z.string().optional().describe('Description for project creation or task decomposition'),
  options: z.record(z.unknown()).optional().describe('Additional options for the command'),
  input: z.string().optional().describe('Natural language input for command processing')
});

// Extract the raw shape for registration
const vibeTaskManagerInputSchemaShape = vibeTaskManagerInputSchema.shape;

/**
 * Check if input is natural language rather than structured command
 */
function isNaturalLanguageInput(params: Record<string, unknown>): boolean {
  // If there's an 'input' field, it's natural language
  if (params.input && typeof params.input === 'string') {
    return true;
  }

  // If no command is specified but there's a description that looks like natural language
  if (!params.command && params.description && typeof params.description === 'string') {
    const desc = params.description.toLowerCase();
    // Look for natural language patterns
    const nlPatterns = [
      /^(create|make|build|start|begin)/,
      /^(list|show|display|get)/,
      /^(run|execute|start|launch)/,
      /^(check|status|what|how)/,
      /^(refine|improve|update|modify)/,
      /^(decompose|break down|split)/
    ];
    return nlPatterns.some(pattern => pattern.test(desc));
  }

  return false;
}

/**
 * Handle natural language input - SIMPLIFIED VERSION
 */
async function handleNaturalLanguageInput(
  input: string,
  config: OpenRouterConfig,
  context: any
): Promise<CallToolResult> {
  // Simplified natural language processing without complex imports
  const inputLower = input.toLowerCase();
  
  if (inputLower.includes('create') || inputLower.includes('new project')) {
    return {
      content: [{
        type: "text",
        text: `‚úÖ Natural language: Creating project based on: "${input}"`
      }]
    };
  }
  
  if (inputLower.includes('list') || inputLower.includes('show')) {
    return {
      content: [{
        type: "text",
        text: `üìã Natural language: Listing projects based on: "${input}"`
      }]
    };
  }
  
  return {
    content: [{
      type: "text",
      text: `‚ùå Failed to understand: "${input}"\n\nTry:\n‚Ä¢ create project [name]\n‚Ä¢ list projects\n‚Ä¢ Or use structured commands`
    }],
    isError: true
  };
}



/**
 * Main executor function for the Vibe Task Manager tool
 * Implements AI-agent-native task management with recursive decomposition
 * WITH HANG PROTECTION
 */
export const vibeTaskManagerExecutor: ToolExecutor = async (
  params: Record<string, unknown>,
  config: OpenRouterConfig,
  context?: ToolExecutionContext
): Promise<CallToolResult> => {
  const sessionId = context?.sessionId || 'unknown-session';
  const executionStart = Date.now();
  const MAX_EXECUTION_TIME = 10000; // 10 seconds max execution time

  // Set up aggressive hang protection
  const hangProtectionTimer = setTimeout(() => {
    logger.error({
      sessionId,
      executionTime: Date.now() - executionStart,
      params
    }, 'HANG PROTECTION: Forcefully terminating vibe-task-manager execution');
    
    // This won't actually stop the execution but will log the hang
    throw new Error('HANG PROTECTION: Execution terminated due to timeout');
  }, MAX_EXECUTION_TIME);

  try {
    logger.info({ sessionId, params, maxTime: MAX_EXECUTION_TIME }, 'Vibe Task Manager execution started with hang protection');

    // Quick validation without complex operations
    const validatedParams = vibeTaskManagerInputSchema.parse(params);
    const { command, projectName, taskId, description, options, input } = validatedParams;

    // Clear the timeout as we're proceeding normally
    clearTimeout(hangProtectionTimer);

    // Check if this is natural language input
    if (isNaturalLanguageInput(params)) {
      return await handleNaturalLanguageInput(input || description || '', config, context);
    }

    // Validate command is provided
    if (!command) {
      return {
        content: [{
          type: "text",
          text: "Validation error: command is required. Please specify one of: create, list, run, status, refine, decompose"
        }],
        isError: true
      };
    }

    // Route to appropriate command handler with individual timeouts
    const commandTimeout = setTimeout(() => {
      throw new Error(`Command '${command}' execution timeout after ${MAX_EXECUTION_TIME}ms`);
    }, MAX_EXECUTION_TIME);

    let result: CallToolResult;

    switch (command) {
      case 'create':
        result = await handleCreateCommand(projectName, description, options, config, sessionId);
        break;
      case 'list':
        result = await handleListCommand(options, sessionId);
        break;
      case 'run':
        result = await handleRunCommand(taskId, options, config, sessionId);
        break;
      case 'status':
        result = await handleStatusCommand(projectName, taskId, sessionId);
        break;
      case 'refine':
        result = await handleRefineCommand(taskId, description, config, sessionId);
        break;
      case 'decompose':
        result = await handleDecomposeCommand(taskId || projectName, description, config, sessionId);
        break;
      default:
        result = {
          content: [{
            type: "text",
            text: `Validation error: Unknown command '${command}'. Valid commands are: create, list, run, status, refine, decompose`
          }],
          isError: true
        };
    }

    clearTimeout(commandTimeout);
    
    logger.info({
      sessionId,
      command,
      executionTime: Date.now() - executionStart
    }, 'Vibe Task Manager command completed successfully');

    return result;

  } catch (error) {
    clearTimeout(hangProtectionTimer);
    
    logger.error({ 
      err: error, 
      sessionId, 
      params,
      executionTime: Date.now() - executionStart
    }, 'Vibe Task Manager execution failed');

    if (error instanceof z.ZodError) {
      return {
        content: [{
          type: "text",
          text: `Validation error: ${error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ')}`
        }],
        isError: true
      };
    }

    return {
      content: [{
        type: "text",
        text: `Error: ${error instanceof Error ? error.message : String(error)}`
      }],
      isError: true
    };
  }
};

/**
 * Wait for decomposition completion using reliable polling approach
 */
async function waitForDecompositionCompletion(
  decompositionService: DecompositionService,
  sessionId: string,
  maxWaitTime: number = 30000
): Promise<AtomicTask[]> {
  const startTime = Date.now();
  const pollInterval = 500; // Poll every 500ms

  logger.debug({
    sessionId,
    maxWaitTime,
    pollInterval
  }, 'Starting decomposition completion polling');

  while (Date.now() - startTime < maxWaitTime) {
    const session = decompositionService.getSession(sessionId);
    
    if (!session) {
      throw new Error('Decomposition session not found');
    }

    logger.debug({
      sessionId,
      status: session.status,
      progress: session.progress,
      elapsedTime: Date.now() - startTime
    }, 'Polling decomposition status');

    if (session.status === 'completed') {
      const results = decompositionService.getResults(sessionId);
      logger.info({
        sessionId,
        resultsLength: results.length,
        totalTime: Date.now() - startTime
      }, 'Decomposition completed successfully');
      return results;
    }

    if (session.status === 'failed') {
      const error = session.error || 'Decomposition failed';
      logger.error({
        sessionId,
        error,
        totalTime: Date.now() - startTime
      }, 'Decomposition failed');
      throw new Error(error);
    }

    // Wait before next poll
    await new Promise(resolve => setTimeout(resolve, pollInterval));
  }

  const error = `Decomposition timeout after ${maxWaitTime}ms`;
  logger.error({
    sessionId,
    maxWaitTime,
    totalTime: Date.now() - startTime
  }, error);
  throw new Error(error);
}

// Stub implementations for the command handlers with hang protection
async function handleCreateCommand(
  projectName: string | undefined,
  description: string | undefined,
  options: Record<string, unknown> | undefined,
  config: OpenRouterConfig,
  sessionId: string
): Promise<CallToolResult> {
  const startTime = Date.now();
  const timeout = setTimeout(() => {
    throw new Error('handleCreateCommand timeout after 5000ms');
  }, 5000);

  try {
    logger.info({ sessionId, projectName }, 'Creating project with hang protection');
    
    const result = {
      content: [{
        type: "text" as const,
        text: `‚úÖ Create command received for project: ${projectName || 'unnamed'}\nDescription: ${description || 'no description'}\nExecution time: ${Date.now() - startTime}ms`
      }]
    };
    
    clearTimeout(timeout);
    return result;
  } catch (error) {
    clearTimeout(timeout);
    throw error;
  }
}

async function handleListCommand(
  options: Record<string, unknown> | undefined,
  sessionId: string
): Promise<CallToolResult> {
  const startTime = Date.now();
  const timeout = setTimeout(() => {
    throw new Error('handleListCommand timeout after 5000ms');
  }, 5000);

  try {
    logger.info({ sessionId }, 'Listing projects with hang protection');
    
    const result = {
      content: [{
        type: "text" as const,
        text: `üìã List command received with options: ${JSON.stringify(options || {})}\nExecution time: ${Date.now() - startTime}ms`
      }]
    };
    
    clearTimeout(timeout);
    return result;
  } catch (error) {
    clearTimeout(timeout);
    throw error;
  }
}

async function handleRunCommand(
  taskId: string | undefined,
  options: Record<string, unknown> | undefined,
  config: OpenRouterConfig,
  sessionId: string
): Promise<CallToolResult> {
  const startTime = Date.now();
  const timeout = setTimeout(() => {
    throw new Error('handleRunCommand timeout after 5000ms');
  }, 5000);

  try {
    logger.info({ sessionId, taskId }, 'Running task with hang protection');
    
    const result = {
      content: [{
        type: "text" as const,
        text: `üöÄ Run command received for task: ${taskId || 'no task specified'}\nExecution time: ${Date.now() - startTime}ms`
      }]
    };
    
    clearTimeout(timeout);
    return result;
  } catch (error) {
    clearTimeout(timeout);
    throw error;
  }
}

async function handleStatusCommand(
  projectName: string | undefined,
  taskId: string | undefined,
  sessionId: string
): Promise<CallToolResult> {
  const startTime = Date.now();
  const timeout = setTimeout(() => {
    throw new Error('handleStatusCommand timeout after 5000ms');
  }, 5000);

  try {
    logger.info({ sessionId, projectName, taskId }, 'Getting status with hang protection');
    
    const result = {
      content: [{
        type: "text" as const,
        text: `üìä Status command received for project: ${projectName || 'none'}, task: ${taskId || 'none'}\nExecution time: ${Date.now() - startTime}ms`
      }]
    };
    
    clearTimeout(timeout);
    return result;
  } catch (error) {
    clearTimeout(timeout);
    throw error;
  }
}

async function handleRefineCommand(
  taskId: string | undefined,
  description: string | undefined,
  config: OpenRouterConfig,
  sessionId: string
): Promise<CallToolResult> {
  const startTime = Date.now();
  const timeout = setTimeout(() => {
    throw new Error('handleRefineCommand timeout after 5000ms');
  }, 5000);

  try {
    logger.info({ sessionId, taskId }, 'Refining task with hang protection');
    
    const result = {
      content: [{
        type: "text" as const,
        text: `üîÑ Refine command received for task: ${taskId || 'no task'} with description: ${description || 'no description'}\nExecution time: ${Date.now() - startTime}ms`
      }]
    };
    
    clearTimeout(timeout);
    return result;
  } catch (error) {
    clearTimeout(timeout);
    throw error;
  }
}

async function handleDecomposeCommand(
  target: string | undefined,
  description: string | undefined,
  config: OpenRouterConfig,
  sessionId: string
): Promise<CallToolResult> {
  const startTime = Date.now();
  const timeout = setTimeout(() => {
    throw new Error('handleDecomposeCommand timeout after 5000ms');
  }, 5000);

  try {
    logger.info({ sessionId, target }, 'Decomposing with hang protection');
    
    const result = {
      content: [{
        type: "text" as const,
        text: `üîÄ Decompose command received for target: ${target || 'no target'} with description: ${description || 'no description'}\nExecution time: ${Date.now() - startTime}ms`
      }]
    };
    
    clearTimeout(timeout);
    return result;
  } catch (error) {
    clearTimeout(timeout);
    throw error;
  }
}

// Stub for ensureAgentRegistration
async function ensureAgentRegistration(sessionId: string, context?: ToolExecutionContext): Promise<void> {
  logger.debug({ sessionId }, 'Agent registration stub called');
}

// Tool definition for registration
const vibeTaskManagerDefinition: ToolDefinition = {
  name: "vibe-task-manager",
  description: "AI-agent-native task management system with recursive decomposition design (RDD) methodology. Supports project creation, task decomposition, dependency management, and agent coordination for autonomous software development workflows.",
  inputSchema: vibeTaskManagerInputSchemaShape,
  executor: vibeTaskManagerExecutor
};

// Register the tool with the central registry
registerTool(vibeTaskManagerDefinition);

logger.debug('Vibe Task Manager tool registered successfully');

// Export functions for testing
export { };
