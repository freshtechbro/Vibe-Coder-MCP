// src/tools/prd-generator/tests/index.test.ts
import { CallToolResult, McpError } from '@modelcontextprotocol/sdk/types.js';
import fs from 'fs-extra';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

import { jobManager, JobStatus } from '../../../services/job-manager/index.js';
import { sseNotifier } from '../../../services/sse-notifier/index.js';
import { OpenRouterConfig } from '../../../types/workflow.js';
import { ApiError } from '../../../utils/errors.js';
import * as llmHelper from '../../../utils/llmHelper.js';
import * as researchHelper from '../../../utils/researchHelper.js';
import { generatePRD, PRD_SYSTEM_PROMPT } from '../index.js';

// Mock dependencies
vi.mock('../../../utils/researchHelper.js');
vi.mock('../../../utils/llmHelper.js');
vi.mock('fs-extra');
vi.mock('../../../logger.js');
vi.mock('../../../services/job-manager/index.js');
vi.mock('../../../services/sse-notifier/index.js');

// Define helper variables for mocks using vi.mocked() for better type handling
const mockPerformResearchQuery = vi.mocked(researchHelper.performResearchQuery);
const mockPerformDirectLlmCall = vi.mocked(llmHelper.performDirectLlmCall);
const mockWriteFile = vi.mocked(fs.writeFile);
const mockEnsureDir = vi.mocked(fs.ensureDir);

// Helper to advance timers and allow setImmediate to run
const runAsyncTicks = async (count = 1) => {
  for (let i = 0; i < count; i++) {
    await vi.advanceTimersToNextTimerAsync();
  }
};

const mockJobId = 'mock-prd-job-id';

describe('PRD Generator Tool Executor (Async)', () => {
  // Mock data and responses
  const mockConfig: OpenRouterConfig = {
    baseUrl: 'mock-url',
    apiKey: 'test-api-key',
    geminiModel: 'google/gemini-2.5-pro-exp-03-25:free',
    perplexityModel: 'perplexity/sonar-deep-research',
    defaultModel: 'gpt-4-turbo',
    temperature: 0.7,
    maxTokens: 2048,
  };
  const mockContext = { sessionId: 'test-session-prd' };

  const mockResearchResults = [
    'Mock market analysis research data',
    'Mock user needs research data',
    'Mock industry standards research data',
  ];

  const mockGeneratedPRD =
    '# Mock PRD\n\nThis is a mock PRD generated by the test.';

  beforeEach(() => {
    // Reset mocks before each test
    vi.clearAllMocks();

    // Default mocks for successful execution
    mockEnsureDir.mockResolvedValue(undefined);
    mockWriteFile.mockResolvedValue(undefined);
    // Setup mock chain for research queries
    mockPerformResearchQuery
      .mockResolvedValueOnce(mockResearchResults[0])
      .mockResolvedValueOnce(mockResearchResults[1])
      .mockResolvedValueOnce(mockResearchResults[2]);
    mockPerformDirectLlmCall.mockResolvedValue(mockGeneratedPRD);

    // Mock Job Manager methods
    vi.mocked(jobManager.createJob).mockReturnValue(mockJobId);
    vi.mocked(jobManager.updateJobStatus).mockImplementation(() => {});
    vi.mocked(jobManager.setJobResult).mockImplementation(() => {});

    // Enable fake timers
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.restoreAllMocks();
    vi.useRealTimers();
  });

  it('should return job ID and complete successfully in background', async () => {
    const productDescription = 'Fancy New Widget';
    const params = { productDescription };

    // --- Initial Call ---
    const initialResult = await generatePRD(params, mockConfig, mockContext);
    expect(initialResult.isError).toBe(false);
    expect(initialResult.content[0]?.text).toContain(
      `PRD generation started. Job ID: ${mockJobId}`
    );
    expect(jobManager.createJob).toHaveBeenCalledWith('generate-prd', params);

    // Verify underlying logic not called yet
    expect(mockPerformResearchQuery).not.toHaveBeenCalled();
    expect(mockPerformDirectLlmCall).not.toHaveBeenCalled();
    expect(mockWriteFile).not.toHaveBeenCalled();
    expect(jobManager.setJobResult).not.toHaveBeenCalled();

    // --- Advance Timers ---
    await runAsyncTicks(5);

    // --- Verify Async Operations ---
    // 1. Verify Research
    expect(mockPerformResearchQuery).toHaveBeenCalledTimes(3);
    expect(mockPerformResearchQuery).toHaveBeenCalledWith(
      expect.stringContaining(`Market analysis`),
      mockConfig
    );

    // 2. Verify LLM Call
    expect(mockPerformDirectLlmCall).toHaveBeenCalledTimes(1);
    const llmCallArgs = mockPerformDirectLlmCall.mock.calls[0];
    expect(llmCallArgs[0]).toContain(productDescription);
    expect(llmCallArgs[1]).toBe(PRD_SYSTEM_PROMPT);
    expect(llmCallArgs[3]).toBe('prd_generation');

    // 3. Verify File Saving
    expect(mockWriteFile).toHaveBeenCalledTimes(1);
    const writeFileArgs = mockWriteFile.mock.calls[0];
    expect(writeFileArgs[0]).toMatch(
      /prd-generator[\\/].*fancy-new-widget.*-prd\.md$/
    );
    expect(writeFileArgs[1]).toContain(mockGeneratedPRD);

    // 4. Verify Final Job Result
    expect(jobManager.setJobResult).toHaveBeenCalledTimes(1);
    const finalResultArgs = vi.mocked(jobManager.setJobResult).mock.calls[0];
    expect(finalResultArgs[0]).toBe(mockJobId);
    const result = finalResultArgs[1] as {
      isError: boolean;
      content: Array<{ type: string; text: string }>;
    };
    expect(result.isError).toBe(false);
    expect(result.content[0]?.text).toContain(
      `PRD generated successfully and saved to:`
    );
    expect(result.content[0]?.text).toContain(mockGeneratedPRD);

    // 5. Verify SSE Calls (basic)
    expect(sseNotifier.sendProgress).toHaveBeenCalledWith(
      mockContext.sessionId,
      mockJobId,
      JobStatus.RUNNING,
      expect.stringContaining('Starting PRD generation')
    );
    expect(sseNotifier.sendProgress).toHaveBeenCalledWith(
      mockContext.sessionId,
      mockJobId,
      JobStatus.RUNNING,
      expect.stringContaining('Performing pre-generation research')
    );
    expect(sseNotifier.sendProgress).toHaveBeenCalledWith(
      mockContext.sessionId,
      mockJobId,
      JobStatus.RUNNING,
      expect.stringContaining('Generating PRD content via LLM')
    );
    expect(sseNotifier.sendProgress).toHaveBeenCalledWith(
      mockContext.sessionId,
      mockJobId,
      JobStatus.RUNNING,
      expect.stringContaining('Saving PRD to file')
    );
  });

  it('should handle research failures gracefully (async)', async () => {
    // Mock one research query to fail
    mockPerformResearchQuery.mockReset();
    mockPerformResearchQuery
      .mockRejectedValueOnce(new ApiError('Market research failed', 500))
      .mockResolvedValueOnce(mockResearchResults[1])
      .mockResolvedValueOnce(mockResearchResults[2]);

    const productDescription = 'Widget With Failing Research';
    // --- Initial Call ---
    await generatePRD({ productDescription }, mockConfig, mockContext);
    // --- Advance Timers ---
    await runAsyncTicks(5);
    // --- Verify Async Operations ---
    expect(mockPerformDirectLlmCall).toHaveBeenCalledTimes(1);
    const mainPromptArg = mockPerformDirectLlmCall.mock.calls[0][0];
    expect(mainPromptArg).toContain(
      '### Market Analysis:\n*Research on this topic failed.*\n\n'
    );
    expect(mockWriteFile).toHaveBeenCalledTimes(1);
    expect(jobManager.setJobResult).toHaveBeenCalledTimes(1);
    const result = vi.mocked(jobManager.setJobResult).mock.calls[0][1] as {
      isError: boolean;
    };
    expect(result.isError).toBe(false);
    expect(sseNotifier.sendProgress).toHaveBeenCalledWith(
      mockContext.sessionId,
      mockJobId,
      JobStatus.RUNNING,
      expect.stringContaining('Warning: Error during research phase')
    );
  });

  it('should set job to FAILED if direct LLM call throws error (async)', async () => {
    const llmError = new ApiError('LLM call failed', 500);
    mockPerformDirectLlmCall.mockRejectedValueOnce(llmError);

    const productDescription = 'Confusing Widget';
    // --- Initial Call ---
    await generatePRD({ productDescription }, mockConfig, mockContext);
    // --- Advance Timers ---
    await runAsyncTicks(5);
    // --- Verify Async Operations ---
    expect(mockPerformResearchQuery).toHaveBeenCalledTimes(3);
    expect(mockPerformDirectLlmCall).toHaveBeenCalledTimes(1);
    expect(mockWriteFile).not.toHaveBeenCalled();
    expect(jobManager.setJobResult).toHaveBeenCalledTimes(1);
    const finalResultArgs = vi.mocked(jobManager.setJobResult).mock.calls[0];
    expect(finalResultArgs[0]).toBe(mockJobId);
    const result = finalResultArgs[1] as {
      isError: boolean;
      content: Array<{ type: string; text: string }>;
      errorDetails: McpError;
    };
    expect(result.isError).toBe(true);
    expect(result.content[0]?.text).toContain('Error during background job');
    const errorDetails = result.errorDetails;
    expect(errorDetails?.message).toContain(
      'Failed to generate PRD: LLM call failed'
    );
  });

  it('should set job to FAILED if file writing fails (async)', async () => {
    const fileWriteError = new Error('Disk full');
    mockWriteFile.mockRejectedValueOnce(fileWriteError);

    const productDescription = 'Unsavable Widget';
    // --- Initial Call ---
    await generatePRD({ productDescription }, mockConfig, mockContext);
    // --- Advance Timers ---
    await runAsyncTicks(5);
    // --- Verify Async Operations ---
    expect(mockPerformResearchQuery).toHaveBeenCalledTimes(3);
    expect(mockPerformDirectLlmCall).toHaveBeenCalledTimes(1);
    expect(mockWriteFile).toHaveBeenCalledTimes(1);
    expect(jobManager.setJobResult).toHaveBeenCalledTimes(1);
    const finalResultArgs = vi.mocked(jobManager.setJobResult).mock.calls[0];
    expect(finalResultArgs[0]).toBe(mockJobId);
    const result = finalResultArgs[1] as {
      isError: boolean;
      content: Array<{ type: string; text: string }>;
      errorDetails: McpError;
    };
    expect(result.isError).toBe(true);
    expect(result.content[0]?.text).toContain('Error during background job');
    const errorDetails = result.errorDetails;
    expect(errorDetails?.message).toContain(
      'Failed to generate PRD: Disk full'
    );
  });

  it('should set final job result content matching snapshot (async)', async () => {
    const productDescription = 'A sample product for snapshot';
    const params = { productDescription };
    const consistentMockPRD =
      '# Mock PRD\n## Section 1\nDetails...\n## Section 2\nMore details...';

    // Reset mocks for consistency
    mockPerformResearchQuery.mockReset();
    mockPerformResearchQuery.mockResolvedValue('Consistent mock research.');
    mockPerformDirectLlmCall.mockReset();
    mockPerformDirectLlmCall.mockResolvedValue(consistentMockPRD);
    mockWriteFile.mockReset();
    mockWriteFile.mockResolvedValue(undefined);

    // --- Initial Call ---
    await generatePRD(params, mockConfig, mockContext);
    // --- Advance Timers ---
    await runAsyncTicks(5);
    // --- Verify Async Operations ---
    expect(jobManager.setJobResult).toHaveBeenCalledTimes(1);
    const finalResultArgs = vi.mocked(jobManager.setJobResult).mock.calls[0];
    const result = finalResultArgs[1] as {
      isError: boolean;
      content: Array<{ type: string; text: string }>;
    };
    expect(result.isError).toBe(false);
    const finalResult = result as CallToolResult;

    // Snapshot the main content excluding the timestamp and file path
    const resultText = finalResult.content?.[0]?.text ?? '';
    const contentToSnapshot = (resultText as string)
      .replace(/_Generated: .*_$/, '')
      .replace(/PRD generated successfully and saved to: .*?-prd\.md\n\n/, '')
      .trim();
    expect(contentToSnapshot).toMatchSnapshot('PRD Generator Content');

    // Verify file write happened
    expect(mockWriteFile).toHaveBeenCalledTimes(1);
    expect(mockWriteFile).toHaveBeenCalledWith(
      expect.stringContaining('-prd.md'),
      expect.any(String),
      'utf8'
    );
  });
});
