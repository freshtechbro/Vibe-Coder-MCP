import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import yaml from 'js-yaml';
import logger from '../../logger.js';
import { StarterKitDefinition, FileStructureItem, fileStructureItemSchema } from './schema.js';
import { AppError, ParsingError, ConfigurationError, ToolExecutionError } from '../../utils/errors.js';
import { OpenRouterConfig } from '../../types/workflow.js';
import { performFormatAwareLlmCall, normalizeJsonResponse } from '../../utils/llmHelper.js';
import { z } from 'zod';

// Get the directory name equivalent to __dirname in CommonJS
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Define structure for a loaded and parsed YAML module
export interface ParsedYamlModule {
  moduleName: string;
  description?: string;
  type?: string; // e.g., frontend, backend, database, auth
  placeholders?: string[];
  provides: {
    techStack?: Record<string, { name: string; version?: string; rationale: string }>;
    directoryStructure?: FileStructureItem[];
    dependencies?: StarterKitDefinition['dependencies'];
    setupCommands?: { context?: string; command: string }[];
  };
  _sourcePath?: string; // Internal, not generated by LLM but added after loading/generation
}

// Zod schema for ParsedYamlModule (for validating LLM output)
// Note: FileStructureItem is recursive, so we use its exported schema.
const parsedYamlModuleSchema = z.object({
  moduleName: z.string().min(1),
  description: z.string().optional(),
  type: z.string().optional(),
  placeholders: z.array(z.string()).optional(),
  provides: z.object({
    techStack: z.record(z.object({
      name: z.string(),
      version: z.string().optional(),
      rationale: z.string(),
    })).optional(),
    directoryStructure: z.array(fileStructureItemSchema).optional(),
    dependencies: z.object({
      npm: z.object({
        root: z.object({
          dependencies: z.record(z.string()).optional(),
          devDependencies: z.record(z.string()).optional(),
        }).optional(),
      }).catchall(z.object({
        dependencies: z.record(z.string()).optional(),
        devDependencies: z.record(z.string()).optional(),
      })).optional(),
    }).optional(),
    setupCommands: z.array(z.object({
      context: z.string().optional(),
      command: z.string(),
    })).optional(),
  }),
});

// Parameters to customize selected modules
interface ModuleParameters {
  [placeholderKey: string]: string | number | boolean;
}

export class YAMLComposer {
  private baseTemplatePath: string;
  private config: OpenRouterConfig;
  private generatedTemplateCache: Map<string, ParsedYamlModule> = new Map();

  // Template name aliases to handle variations (e.g., postgres vs postgresql)
  private templateAliases: Map<string, string> = new Map([
    ['database/postgres', 'database/postgresql'],
    ['database/postgresql', 'database/postgres'],
    ['auth/authentication', 'auth/jwt'],
    ['auth/jwt', 'auth/authentication'],
  ]);

  constructor(config: OpenRouterConfig, baseTemplatePath: string = path.join(__dirname, 'templates')) {
    this.baseTemplatePath = baseTemplatePath;
    this.config = config;
  }

  private async generateTemplateWithLLM(category: string, technology: string, modulePathSegment: string): Promise<string> {
    const systemPrompt = `You are an expert YAML template generator for a full-stack starter kit.
Your task is to generate a JSON object that represents the structure of a YAML module file.
This JSON object must conform to the ParsedYamlModule TypeScript interface structure provided below.
The generated module is for: Category '${category}', Technology '${technology}'.
The module path segment is '${modulePathSegment}'.

=== CRITICAL JSON FORMATTING REQUIREMENTS ===
üö® RESPOND WITH ONLY A VALID JSON OBJECT - NO MARKDOWN, NO CODE BLOCKS, NO EXPLANATIONS, NO SURROUNDING TEXT
üö® THE RESPONSE MUST BE A JSON OBJECT (starting with { and ending with }), NEVER AN ARRAY
üö® DO NOT RETURN ARRAYS OF STRINGS - RETURN A COMPLETE OBJECT STRUCTURE
üö® FAILURE TO FOLLOW THESE RULES WILL CAUSE SYSTEM FAILURE

JSON SYNTAX RULES:
1. Use double quotes for ALL strings and property names (never single quotes)
2. Escape ALL special characters in string values:
   - Newlines: \\n (not actual line breaks)
   - Tabs: \\t
   - Backslashes: \\\\
   - Double quotes: \\"
   - Carriage returns: \\r
3. For multi-line code content, use \\n for line breaks within the string
4. Ensure all braces {} and brackets [] are properly closed and balanced
5. Do NOT include trailing commas after the last property/element
6. Do NOT include comments (// or /* */)
7. Do NOT wrap response in markdown code blocks like \`\`\`json
8. Do NOT include any text before or after the JSON object

EDGE CASE HANDLING:
- File paths: Use forward slashes / (never backslashes \\)
- Empty arrays: Use [] (not null)
- Empty objects: Use {} (not null)
- Boolean values: Use true/false (not "true"/"false")
- Numbers: Use numeric values (not strings) for ports, versions when numeric
- Null values: Use null (not "null", undefined, or empty string)
- Unicode characters: Escape as \\uXXXX if problematic
- Control characters (\\x00-\\x1F): Must be escaped as \\uXXXX
- Large code blocks: Keep as single string with \\n separators

CONTENT STRING FORMATTING EXAMPLES:
‚ùå WRONG: "content": "console.log('Hello');
console.log('World');"

‚úÖ CORRECT: "content": "console.log('Hello');\\nconsole.log('World');"

‚ùå WRONG: "content": "const path = "src\\\\components""

‚úÖ CORRECT: "content": "const path = \\"src/components\\""

JSON Structure to follow:
{
  "moduleName": "string (e.g., ${technology}-${category})",
  "description": "string (e.g., ${technology} ${category} module for {projectName})",
  "type": "string (e.g., ${category})",
  "placeholders": ["string"], // Optional: e.g., ["projectName", "portNumber"]
  "provides": {
    "techStack": { // Optional
      "uniqueKeyPerStackItem": { "name": "string", "version": "string (optional)", "rationale": "string" }
    },
    "directoryStructure": [ // Optional: Array of FileStructureItem-like objects. Paths are relative to module root.
      // Example: { "path": "src/index.js", "type": "file", "content": "console.log('Hello {projectName}');", "generationPrompt": null },
      // Example: { "path": "src/components/", "type": "directory", "content": null, "children": [] }
    ],
    "dependencies": { // Optional
      "npm": {
        // e.g., "{frontendPath}": { "dependencies": {"react": "^18.0.0"} }
      }
    },
    "setupCommands": [ // Optional
      // { "context": "{${category}Path}", "command": "npm install" }
    ]
  }
}

CRITICAL SCHEMA REQUIREMENTS:
- Generate ONLY the raw JSON object. Do NOT use Markdown, code blocks, or any surrounding text.
- The response MUST be a complete object with moduleName, description, type, and provides fields.
- NEVER return just an array of strings - always return the full object structure.
- Ensure all paths in 'directoryStructure' are relative to the module's own root.
- For 'directoryStructure' items:
  * Files (type: "file") MUST have "content" as a string OR "generationPrompt" as a string, but NOT both
  * Directories (type: "directory") MUST have "content": null and MAY have "children" array
  * ALL items MUST include the "content" field (string for files, null for directories)
- If 'content' for a file is provided, 'generationPrompt' should be null/undefined, and vice-versa.
- Use common placeholders like {projectName}, {backendPort}, {frontendPort}, {frontendPath}, {backendPath} where appropriate.

EXAMPLE STRUCTURE (for reference - adapt for your specific technology):
{
  "moduleName": "example-module",
  "description": "Example module description",
  "type": "database",
  "placeholders": ["projectName", "dbPort"],
  "provides": {
    "techStack": {
      "technology": {
        "name": "Technology Name",
        "version": "latest",
        "rationale": "Why this technology"
      }
    },
    "directoryStructure": [
      {
        "path": "config.yml",
        "type": "file",
        "content": "example: {projectName}",
        "generationPrompt": null
      }
    ],
    "dependencies": {},
    "setupCommands": [
      {
        "context": "root",
        "command": "setup command"
      }
    ]
  }
}
- Be comprehensive but sensible for a starter module of type '${category}' using '${technology}'.
- Example: "dependencies": { "npm": { "{frontendPath}": { "dependencies": {"react": "^18.0.0"} } } }
- If the module is self-contained, dependencies might be under "root":
  "dependencies": { "npm": { "root": { "devDependencies": {"husky": "^8.0.0"} } } }

VALIDATION CHECKLIST BEFORE RESPONDING:
‚úì JSON object starts with { and ends with }
‚úì All strings use double quotes
‚úì All special characters are properly escaped
‚úì No trailing commas
‚úì No markdown code blocks or surrounding text
‚úì All required fields present (moduleName, description, type, provides)
‚úì Directory items have content: null
‚úì File items have content as string OR generationPrompt as string
‚úì Paths use forward slashes
‚úì Multi-line content uses \\n separators

Generate the JSON for '${modulePathSegment}':`;

    const userPrompt = `Generate the JSON representation for a YAML module.
Category: ${category}
Technology: ${technology}
Module Path Segment: ${modulePathSegment}

Consider typical files, dependencies, and configurations for this type of module.
For example, if it's a 'nodejs-express' backend, include basic Express setup, a sample route, package.json, tsconfig.json.
If it's a 'react-vite' frontend, include basic React/Vite setup, sample components, package.json, vite.config.ts.
Provide a sensible set of placeholders if needed (e.g. "{projectName}", "{backendPort}").
Ensure the output is a single, raw JSON object without any other text or formatting.`;

    try {
      logger.info(`Requesting LLM to generate template for: ${modulePathSegment}`);
      const rawResponse = await performFormatAwareLlmCall(
        userPrompt,
        systemPrompt,
        this.config,
        'fullstack_starter_kit_dynamic_yaml_module_generation',
        'json', // Explicitly specify JSON format
        undefined, // Schema will be inferred from task name
        0.2
      );
      logger.debug({ modulePathSegment, rawResponseFromLLM: rawResponse }, "Raw LLM response for dynamic template");
      return rawResponse;
    } catch (error) {
      logger.error({ err: error, modulePathSegment }, `LLM call failed during dynamic template generation for ${modulePathSegment}`);
      throw new ToolExecutionError(`LLM failed to generate template for ${modulePathSegment}: ${(error as Error).message}`, undefined, error instanceof Error ? error : undefined);
    }
  }

  private async generateDynamicTemplate(modulePathSegment: string): Promise<ParsedYamlModule> {
    logger.info(`Attempting to dynamically generate YAML module: ${modulePathSegment}`);
    const parts = modulePathSegment.split('/');
    const technology = parts.pop() || modulePathSegment;
    const category = parts.join('/') || 'general';

    const llmResponse = await this.generateTemplateWithLLM(category, technology, modulePathSegment);

    let parsedJson: Record<string, unknown>;
    try {
      // Use intelligent parsing with validation-first approach
      // This only applies preprocessing when needed, avoiding unnecessary data loss
      const { intelligentJsonParse } = await import('../../utils/llmHelper.js');
      const parsed = intelligentJsonParse(llmResponse, `dynamic-gen-${modulePathSegment}`);

      // Validate that the response is an object, not an array
      if (Array.isArray(parsed)) {
        logger.error({ modulePathSegment, parsedResponse: parsed, responsePreview: llmResponse.substring(0, 200) }, `LLM returned an array instead of object for ${modulePathSegment}`);
        throw new ParsingError(`LLM returned an array instead of expected object structure for ${modulePathSegment}. Got: ${JSON.stringify(parsed)}`, { originalResponse: llmResponse, parsedResponse: parsed });
      }

      if (typeof parsed !== 'object' || parsed === null) {
        logger.error({ modulePathSegment, parsedResponse: parsed, responsePreview: llmResponse.substring(0, 200) }, `LLM returned invalid type for ${modulePathSegment}`);
        throw new ParsingError(`LLM returned invalid type (expected object) for ${modulePathSegment}. Got: ${typeof parsed}`, { originalResponse: llmResponse, parsedResponse: parsed });
      }

      parsedJson = parsed as Record<string, unknown>;
      logger.debug({ modulePathSegment, responseLength: llmResponse.length, parsedSize: JSON.stringify(parsedJson).length }, "Intelligent JSON parsing successful");
    } catch (error) {
      logger.error({ err: error, modulePathSegment, responsePreview: llmResponse.substring(0, 200) }, `Failed to parse LLM JSON response for ${modulePathSegment} using intelligent parsing`);
      throw new ParsingError(`Failed to parse dynamically generated template for ${modulePathSegment} as JSON using intelligent parsing. Response preview: ${llmResponse.substring(0, 200)}`, { originalResponse: llmResponse }, error instanceof Error ? error : undefined);
    }

    // Preprocess the parsed JSON to fix common schema issues
    const preprocessedJson = this.preprocessTemplateForValidation(parsedJson, modulePathSegment);

    const validationResult = parsedYamlModuleSchema.safeParse(preprocessedJson);
    if (!validationResult.success) {
      logger.error({ err: validationResult.error.issues, modulePathSegment, parsedJson: preprocessedJson }, `Dynamically generated template for ${modulePathSegment} failed Zod validation after preprocessing.`);
      throw new ParsingError(`Dynamically generated template for ${modulePathSegment} failed validation: ${validationResult.error.message}`, { issues: validationResult.error.issues, parsedJson: preprocessedJson });
    }

    const validatedModule = validationResult.data as ParsedYamlModule;
    validatedModule._sourcePath = path.resolve(this.baseTemplatePath, `${modulePathSegment}.yaml`);

    // Save the generated template to disk as YAML
    try {
      const yamlContent = yaml.dump(validatedModule);
      await fs.ensureDir(path.dirname(validatedModule._sourcePath));
      await fs.writeFile(validatedModule._sourcePath, yamlContent, 'utf-8');
      logger.info(`Successfully saved dynamically generated YAML template to: ${validatedModule._sourcePath}`);
    } catch (error) {
      logger.warn({ err: error, modulePathSegment, filePath: validatedModule._sourcePath }, `Failed to save dynamically generated template for ${modulePathSegment}. Proceeding with in-memory version.`);
    }

    this.generatedTemplateCache.set(modulePathSegment, validatedModule);
    logger.info(`Dynamically generated and cached YAML module: ${modulePathSegment}`);
    return validatedModule;
  }

  public async loadAndParseYamlModule(modulePathSegment: string): Promise<ParsedYamlModule> {
    if (this.generatedTemplateCache.has(modulePathSegment)) {
      logger.debug(`Returning cached YAML module for: ${modulePathSegment}`);
      return this.generatedTemplateCache.get(modulePathSegment)!;
    }

    // Try the original path first
    let fullPath = path.resolve(this.baseTemplatePath, `${modulePathSegment}.yaml`);
    logger.debug(`Attempting to load YAML module from: ${fullPath}`);

    // If the file doesn't exist, try template aliases
    if (!(await fs.pathExists(fullPath)) && this.templateAliases.has(modulePathSegment)) {
      const aliasPath = this.templateAliases.get(modulePathSegment)!;
      const aliasFullPath = path.resolve(this.baseTemplatePath, `${aliasPath}.yaml`);
      logger.debug(`Original template not found, trying alias: ${aliasFullPath}`);

      if (await fs.pathExists(aliasFullPath)) {
        fullPath = aliasFullPath;
        logger.info(`Using template alias: ${modulePathSegment} -> ${aliasPath}`);
      }
    }

    if (await fs.pathExists(fullPath)) {
      logger.info(`Found existing YAML module: ${fullPath}`);
      try {
        const fileContent = await fs.readFile(fullPath, 'utf-8');
        const parsed = yaml.load(fileContent) as Record<string, unknown>;
        const validationResult = parsedYamlModuleSchema.safeParse(parsed);
        if (!validationResult.success) {
          logger.error({ errors: validationResult.error.issues, filePath: fullPath, parsedContent: parsed }, "Loaded YAML module failed schema validation");
          throw new ParsingError(`Invalid YAML module structure in ${fullPath}. Validation failed: ${validationResult.error.message}`, { filePath: fullPath, issues: validationResult.error.issues });
        }
        const validatedModule = validationResult.data as ParsedYamlModule;
        validatedModule._sourcePath = fullPath;
        this.generatedTemplateCache.set(modulePathSegment, validatedModule);
        logger.debug(`Loaded and cached YAML module from disk: ${modulePathSegment}`);
        return validatedModule;
      } catch (error) {
        if (error instanceof AppError) throw error;
        const cause = error instanceof Error ? error : undefined;
        logger.error({ err: error, filePath: fullPath }, `Failed to load or parse existing YAML module ${modulePathSegment}`);
        throw new ParsingError(`Failed to load or parse YAML module ${modulePathSegment} from ${fullPath}: ${(cause as Error)?.message}`, { filePath: fullPath }, cause);
      }
    } else {
      logger.warn(`YAML module template not found on disk: ${fullPath}. Attempting dynamic generation.`);
      try {
        return await this.generateDynamicTemplate(modulePathSegment);
      } catch (generationError) {
        logger.error({ err: generationError, modulePathSegment, filePath: fullPath }, `Dynamic generation failed for YAML module ${modulePathSegment}.`);
        throw new ConfigurationError(
          `YAML module template not found at '${fullPath}' and dynamic generation failed: ${(generationError as Error).message}`,
          { modulePathSegment, originalError: generationError }
        );
      }
    }
  }

  /**
   * Preprocesses parsed JSON to fix common schema validation issues
   * Specifically handles missing content fields in directory structures
   */
  private preprocessTemplateForValidation(parsedJson: Record<string, unknown>, modulePathSegment: string): Record<string, unknown> {
    logger.debug({ modulePathSegment }, "Preprocessing template for schema validation");

    // Deep clone to avoid mutating the original
    const processed = JSON.parse(JSON.stringify(parsedJson));

    // Fix directory structure items
    if (processed.provides && processed.provides.directoryStructure && Array.isArray(processed.provides.directoryStructure)) {
      this.fixDirectoryStructureItems(processed.provides.directoryStructure, modulePathSegment);
    }

    return processed;
  }

  /**
   * Recursively fixes directory structure items to ensure schema compliance
   */
  private fixDirectoryStructureItems(items: any[], modulePathSegment: string): void {
    for (const item of items) {
      if (typeof item === 'object' && item !== null) {
        // Ensure content field exists
        if (!('content' in item)) {
          if (item.type === 'directory') {
            item.content = null;
            logger.debug({ modulePathSegment, path: item.path }, "Added missing content: null for directory");
          } else if (item.type === 'file') {
            // If no content and no generationPrompt, add empty content
            if (!('generationPrompt' in item) || item.generationPrompt === null || item.generationPrompt === undefined) {
              item.content = '';
              logger.debug({ modulePathSegment, path: item.path }, "Added missing empty content for file");
            } else {
              item.content = null;
              logger.debug({ modulePathSegment, path: item.path }, "Added missing content: null for file with generationPrompt");
            }
          }
        }

        // Ensure generationPrompt field exists for files
        if (item.type === 'file' && !('generationPrompt' in item)) {
          item.generationPrompt = null;
        }

        // Recursively process children
        if (item.children && Array.isArray(item.children)) {
          this.fixDirectoryStructureItems(item.children, modulePathSegment);
        }
      }
    }
  }

  /**
   * Progressive JSON parsing with enhanced error recovery
   * Implements fallback strategies for common LLM JSON output issues
   */
  private progressiveJsonParse(jsonString: string, context: string): any {
    const strategies = [
      // Strategy 1: Direct parse
      () => {
        logger.debug({ context, strategy: 'direct' }, "Attempting direct JSON parse");
        return JSON.parse(jsonString);
      },

      // Strategy 2: Fix common position-specific errors
      () => {
        logger.debug({ context, strategy: 'position-fixes' }, "Attempting position-specific error fixes");
        let fixed = jsonString;

        // Fix position 2572 type errors (missing commas between properties)
        fixed = fixed.replace(/(":\s*"[^"]*")\s+(")/g, '$1, $2');

        // Fix position 1210 type errors (control characters in strings)
        fixed = fixed.replace(/("content":\s*")([^"]*[\x00-\x1F][^"]*)(")/, (match, start, content, end) => {
          const cleanContent = content.replace(/[\x00-\x1F]/g, (char: string) => {
            const code = char.charCodeAt(0);
            return `\\u${code.toString(16).padStart(4, '0')}`;
          });
          return start + cleanContent + end;
        });

        return JSON.parse(fixed);
      },

      // Strategy 3: Bracket completion
      () => {
        logger.debug({ context, strategy: 'bracket-completion' }, "Attempting bracket completion");
        let completed = jsonString;
        const openBraces = (completed.match(/{/g) || []).length;
        const closeBraces = (completed.match(/}/g) || []).length;
        const openBrackets = (completed.match(/\[/g) || []).length;
        const closeBrackets = (completed.match(/\]/g) || []).length;

        if (openBraces > closeBraces) {
          completed += '}'.repeat(openBraces - closeBraces);
        }
        if (openBrackets > closeBrackets) {
          completed += ']'.repeat(openBrackets - closeBrackets);
        }

        return JSON.parse(completed);
      },

      // Strategy 4: Extract largest valid JSON substring
      () => {
        logger.debug({ context, strategy: 'partial-extraction' }, "Attempting partial JSON extraction");
        let maxValidJson = '';

        for (let end = jsonString.length; end > 0; end--) {
          for (let start = 0; start < end; start++) {
            const substring = jsonString.substring(start, end);
            try {
              JSON.parse(substring);
              if (substring.length > maxValidJson.length) {
                maxValidJson = substring;
              }
            } catch {
              continue;
            }
          }
          if (maxValidJson) break;
        }

        if (!maxValidJson) {
          throw new Error('No valid JSON substring found');
        }

        return JSON.parse(maxValidJson);
      }
    ];

    let lastError: Error | null = null;

    for (let i = 0; i < strategies.length; i++) {
      try {
        const result = strategies[i]();
        logger.debug({ context, strategy: i + 1, success: true }, "Progressive JSON parsing successful");
        return result;
      } catch (error) {
        lastError = error as Error;
        logger.debug({ context, strategy: i + 1, error: error instanceof Error ? error.message : String(error) }, "Progressive JSON parsing strategy failed");
      }
    }

    throw new ParsingError(
      `All progressive JSON parsing strategies failed for ${context}. Last error: ${lastError?.message}`,
      { jsonString: jsonString.substring(0, 500), strategiesAttempted: strategies.length },
      lastError || undefined
    );
  }

  private substitutePlaceholders<T extends object | string | null | undefined>(data: T, params: ModuleParameters): T {
    if (typeof data === 'string') {
      let result: string = data;
      for (const key in params) {
        const placeholder = `{${key}}`;
        result = result.replace(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), String(params[key]));
      }
      return result as unknown as T;
    }
    if (Array.isArray(data)) {
      return data.map(item => this.substitutePlaceholders(item, params)) as T;
    }
    if (typeof data === 'object' && data !== null) {
      const newData = { ...data } as Record<string, unknown>;
      for (const key in newData) {
        newData[key] = this.substitutePlaceholders(newData[key] as string | object | null | undefined, params);
      }
      return newData as T;
    }
    return data;
  }

  private mergeTechStacks(target: StarterKitDefinition['techStack'], source: ParsedYamlModule['provides']['techStack']): void {
    if (source) {
      for (const key in source) {
        if (target[key] && target[key].name !== source[key].name) {
          logger.warn(`TechStack conflict for component '${key}'. Original: '${target[key].name}', New: '${source[key].name}'. Overwriting with new value from module: ${source[key].name}.`);
        }
        target[key] = { ...source[key] };
      }
    }
  }

  private mergeDirectoryStructures(
    target: FileStructureItem[],
    sourceItems: FileStructureItem[] | undefined,
    moduleKey: string,
    moduleParams: ModuleParameters
  ): void {
    if (!sourceItems) return;

    const moduleRootPath = (moduleParams[moduleKey] as string) || '.';

    const findOrCreateTargetDirectory = (pathSegments: string[], currentLevel: FileStructureItem[]): FileStructureItem[] => {
      if (pathSegments.length === 0) return currentLevel;
      const segment = pathSegments.shift()!;
      let dir = currentLevel.find(i => i.path === segment && i.type === 'directory');
      if (!dir) {
        dir = { path: segment, type: 'directory', content: null, children: [] };
        currentLevel.push(dir);
      }
      if (!dir.children) dir.children = [];
      return dir.children;
    };

    let baseTargetChildren = target;
    if (moduleRootPath && moduleRootPath !== '.') {
      const segments = moduleRootPath.split(path.posix.sep).filter(s => s);
      if (segments.length > 0) {
        baseTargetChildren = findOrCreateTargetDirectory(segments, target);
      }
    }

    sourceItems.forEach(sourceItem => {
      const processedSourceItem = this.substitutePlaceholders(sourceItem, moduleParams);
      const existingIndex = baseTargetChildren.findIndex(t => t.path === processedSourceItem.path);

      if (existingIndex !== -1) {
        const existingItem = baseTargetChildren[existingIndex];
        if (existingItem.type === 'directory' && processedSourceItem.type === 'directory' && processedSourceItem.children) {
          logger.debug(`Merging children for directory: ${processedSourceItem.path} under ${moduleRootPath}`);
          if (!existingItem.children) existingItem.children = [];
          this.mergeDirectoryStructures(existingItem.children, processedSourceItem.children, '.', moduleParams);
        } else {
          logger.warn(`Directory structure conflict for path '${processedSourceItem.path}' under '${moduleRootPath}'. Overwriting with item from module.`);
          baseTargetChildren[existingIndex] = processedSourceItem;
        }
      } else {
        baseTargetChildren.push(processedSourceItem);
      }
    });
  }

  private mergeDependencies(target: StarterKitDefinition['dependencies'], source: ParsedYamlModule['provides']['dependencies']): void {
    if (!source) return;
    if (!target.npm) target.npm = {};

    if (source.npm) {
      for (const packageJsonKeyPlaceholder in source.npm) {
        const resolvedPackageJsonKey = this.substitutePlaceholders(packageJsonKeyPlaceholder, {});
        const sourcePkgConfig = source.npm[packageJsonKeyPlaceholder];
        if (!target.npm[resolvedPackageJsonKey]) {
          target.npm[resolvedPackageJsonKey] = {};
        }
        const targetPkgConfig = target.npm[resolvedPackageJsonKey];
        if (sourcePkgConfig.dependencies) {
          if (!targetPkgConfig.dependencies) targetPkgConfig.dependencies = {};
          Object.assign(targetPkgConfig.dependencies, sourcePkgConfig.dependencies);
        }
        if (sourcePkgConfig.devDependencies) {
          if (!targetPkgConfig.devDependencies) targetPkgConfig.devDependencies = {};
          Object.assign(targetPkgConfig.devDependencies, sourcePkgConfig.devDependencies);
        }
      }
    }
  }

  private mergeSetupCommands(target: StarterKitDefinition['setupCommands'], source: ParsedYamlModule['provides']['setupCommands'], moduleParams: ModuleParameters): void {
    if (source) {
      source.forEach(cmdObj => {
        let command = cmdObj.command;
        const resolvedContext = cmdObj.context ? this.substitutePlaceholders(cmdObj.context, moduleParams) : undefined;
        if (resolvedContext && resolvedContext !== '.') {
          command = `(cd ${resolvedContext} && ${command})`;
        }
        target.push(this.substitutePlaceholders(command, moduleParams));
      });
    }
  }

  public async compose(
    moduleSelections: Array<{ modulePath: string; params: ModuleParameters; moduleKey?: string }>,
    globalParams: ModuleParameters
  ): Promise<StarterKitDefinition> {
    const composedDefinition: StarterKitDefinition = {
      projectName: this.substitutePlaceholders(globalParams.projectName as string || 'my-new-project', globalParams),
      description: this.substitutePlaceholders(globalParams.projectDescription as string || 'A new project.', globalParams),
      techStack: {},
      directoryStructure: [],
      dependencies: { npm: { root: { dependencies: {}, devDependencies: {} } } },
      setupCommands: [],
      nextSteps: [],
    };

    for (const selection of moduleSelections) {
      logger.info(`Processing YAML module: ${selection.modulePath} with params: ${JSON.stringify(selection.params)} and moduleKey: ${selection.moduleKey}`);
      const effectiveParams = { ...globalParams, ...selection.params };
      const module = await this.loadAndParseYamlModule(selection.modulePath);
      const processedModuleProvides = this.substitutePlaceholders(module.provides, effectiveParams);
      this.mergeTechStacks(composedDefinition.techStack, processedModuleProvides.techStack);
      this.mergeDirectoryStructures(
        composedDefinition.directoryStructure,
        processedModuleProvides.directoryStructure,
        selection.moduleKey || 'root',
        effectiveParams
      );
      this.mergeDependencies(composedDefinition.dependencies, this.substitutePlaceholders(processedModuleProvides.dependencies, effectiveParams));
      this.mergeSetupCommands(composedDefinition.setupCommands, processedModuleProvides.setupCommands, effectiveParams);

      if (module.type === 'auth' && module.moduleName.includes('jwt')) {
        composedDefinition.nextSteps.push('Configure JWT secrets and token expiration settings.');
      }
    }

    if (composedDefinition.nextSteps.length === 0) {
      composedDefinition.nextSteps.push("Review the generated project structure and files.");
      composedDefinition.nextSteps.push("Run package manager install commands (e.g., `npm install`) in relevant directories if not fully handled by setup commands.");
      composedDefinition.nextSteps.push("Configure environment variables (e.g., in .env files if created).");
      composedDefinition.nextSteps.push("Consult individual module documentation or READMEs if available.");
    }

    logger.debug('Final composed definition (before final validation):', JSON.stringify(composedDefinition, null, 2));
    return composedDefinition;
  }
}