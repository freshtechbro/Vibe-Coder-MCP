// src/tools/task-list-generator/parser.ts

import { v4 as uuidv4 } from 'uuid';

import logger from '../../logger.js'; // Assuming logger is needed
import {
  StructuredTaskList,
  TaskLevel,
  TaskItem,
  GeneralTask,
  SubTask,
  SubSubTask,
} from '../../types/taskList.js'; // Note .js extension

/**
 * Parses the raw markdown output from the LLM into a structured task list.
 * @param rawOutput - The markdown string generated by the LLM based on the template.
 * @returns A StructuredTaskList array.
 */
export function parseTaskListOutput(rawOutput: string): StructuredTaskList {
  const taskList: StructuredTaskList = [];
  let currentGeneralTaskId: string | null = null;
  let currentSubTaskId: string | null = null;

  // Remove the initial '# Task List for: ...' and '## Overall Goal: ...' sections if present
  // This regex finds the first '## General Task:' and takes everything after it.
  const taskSectionMatch = rawOutput.match(/## General Task:[\s\S]*/);
  const taskContent = taskSectionMatch ? taskSectionMatch[0] : '';

  if (!taskContent) {
    logger.warn(
      "No '## General Task:' sections found in LLM output. Unable to parse tasks."
    );
    return [];
  }

  // Split the content by '---' separators between General Tasks, then trim whitespace
  const generalTaskBlocks = taskContent
    .split('\n---\n')
    .map((block) => block.trim())
    .filter((block) => block.length > 0);

  generalTaskBlocks.forEach((generalBlock) => {
    // --- Parse General Task ---
    const generalTaskRegex =
      /^## General Task:\s*(.*)\s*\*Description:\*([\s\S]*)/;
    const generalMatch = generalBlock.match(generalTaskRegex);

    if (!generalMatch) {
      logger.warn(
        { block: generalBlock },
        'Could not parse General Task block.'
      );
      return; // Skip this block
    }

    // Generate a unique ID for the General Task
    const generalTaskId = uuidv4();

    const generalTask: GeneralTask = {
      id: generalTaskId, // Ensure ID is assigned
      title: generalMatch[1].trim(),
      description: generalMatch[2].trim().split('\n### Sub-task:')[0].trim(), // Get description before subtasks start
      level: TaskLevel.GENERAL,
      parentTaskId: null,
    };
    taskList.push(generalTask);
    currentGeneralTaskId = generalTaskId; // Store for sub-tasks to reference
    currentSubTaskId = null; // Reset sub-task parent when starting new general task

    // --- Parse Sub-tasks and Sub-sub-tasks within the General Task block ---
    // Regex to find sub-task sections within the current general task block's description part
    const subTaskRegex =
      /### Sub-task:\s*(.*?)\s*\*Description:\*([\s\S]*?)(?=### Sub-task:|$)/gs;
    let subMatch;
    // Important: Use the remaining part of the general block AFTER the description
    const subTaskContent = generalMatch[2]
      .trim()
      .substring(generalTask.description.length)
      .trim();

    while ((subMatch = subTaskRegex.exec(subTaskContent)) !== null) {
      const subTaskBlock = subMatch[0]; // The whole sub-task block including sub-sub-tasks

      // Generate a unique ID for the Sub Task
      const subTaskId = uuidv4();

      let subTaskDescription = '';
      let goal = '';
      let objectives: string[] = [];
      let impact = '';
      let acceptanceCriteria: string[] = [];

      // Extract basic fields for SubTask
      const subDescMatch = subMatch[2].match(
        /^([\s\S]*?)\n*(?:\*Goal:|\*Objectives:|\*Impact:|\*Acceptance Criteria:|#### Sub-sub-task:|$)/
      );
      subTaskDescription = subDescMatch ? subDescMatch[1].trim() : '';

      goal = extractField(subTaskBlock, 'Goal');
      objectives = extractListField(subTaskBlock, 'Objectives');
      impact = extractField(subTaskBlock, 'Impact');
      acceptanceCriteria = extractListField(
        subTaskBlock,
        'Acceptance Criteria'
      );

      const subTask: SubTask = {
        id: subTaskId, // Ensure ID is assigned
        title: subMatch[1].trim(),
        description: subTaskDescription,
        level: TaskLevel.SUB,
        parentTaskId: currentGeneralTaskId, // Link to the parent General Task
        goal,
        objectives,
        impact,
        acceptanceCriteria,
      };
      taskList.push(subTask);
      currentSubTaskId = subTaskId; // Store for sub-sub-tasks to reference

      // --- Parse Sub-sub-tasks within the Sub-task block ---
      const subSubTaskRegex =
        /#### Sub-sub-task:\s*(.*?)\s*\*Description:\*([\s\S]*?)(?=#### Sub-sub-task:|$)/gs;
      let subSubMatch;
      // Use the content *within* the current sub-task block for finding sub-sub-tasks
      while ((subSubMatch = subSubTaskRegex.exec(subTaskBlock)) !== null) {
        const subSubBlock = subSubMatch[0];

        // Generate a unique ID for the Sub-sub Task
        const subSubTaskId = uuidv4();

        let subSubTaskDescription = '';
        let subSubGoal = '';
        let subSubObjectives: string[] = [];
        let subSubImpact = '';
        let subSubAcceptanceCriteria: string[] = [];

        const subSubDescMatch = subSubMatch[2].match(
          /^([\s\S]*?)\n*(?:\*Goal:|\*Objectives:|\*Impact:|\*Acceptance Criteria:|$)/
        );
        subSubTaskDescription = subSubDescMatch
          ? subSubDescMatch[1].trim()
          : '';

        subSubGoal = extractField(subSubBlock, 'Goal');
        subSubObjectives = extractListField(subSubBlock, 'Objectives');
        subSubImpact = extractField(subSubBlock, 'Impact');
        subSubAcceptanceCriteria = extractListField(
          subSubBlock,
          'Acceptance Criteria'
        );

        const subSubTask: SubSubTask = {
          id: subSubTaskId, // Ensure ID is assigned
          title: subSubMatch[1].trim(),
          description: subSubTaskDescription,
          level: TaskLevel.SUB_SUB,
          parentTaskId: currentSubTaskId, // Link to the parent Sub Task
          goal: subSubGoal,
          objectives: subSubObjectives,
          impact: subSubImpact,
          acceptanceCriteria: subSubAcceptanceCriteria,
        };
        taskList.push(subSubTask);
      }
    }
  });

  // Verify all tasks have IDs and proper parent-child relationships
  const idCheck = taskList.every((task) => !!task.id);
  if (!idCheck) {
    logger.error('Some tasks were parsed without IDs. This should not happen.');
  }

  logger.debug(
    {
      generalTaskCount: taskList.filter(
        (task) => task.level === TaskLevel.GENERAL
      ).length,
      subTaskCount: taskList.filter((task) => task.level === TaskLevel.SUB)
        .length,
      subSubTaskCount: taskList.filter(
        (task) => task.level === TaskLevel.SUB_SUB
      ).length,
    },
    'Parsed task list summary'
  );

  return taskList;
}

// --- Helper Functions ---

/**
 * Extracts a simple text field (like Goal, Impact, Description) following a marker.
 * Assumes field content is single-line or multi-line until the next field marker or heading.
 */
function extractField(block: string, fieldName: string): string {
  // Regex: Finds '*FieldName:*' and captures text until the next '*', '#', or end of block
  const regex = new RegExp(
    `\\*${fieldName}:\\*\\s*([\\s\\S]*?)(?=\\n\\*\\w+:|\\n#|$)`,
    'i'
  );
  const match = block.match(regex);
  return match ? match[1].trim() : '';
}

/**
 * Extracts list items (like Objectives, Acceptance Criteria) following a marker.
 * Assumes list items start with '-' and may have indentation.
 */
function extractListField(block: string, fieldName: string): string[] {
  // Regex: Finds '*FieldName:*', then captures all subsequent lines starting with '-'
  const regex = new RegExp(
    `\\*${fieldName}:\\*\\s*\\n((?:-\\s*.*(?:\\n|$))+)`,
    'i'
  );
  const match = block.match(regex);
  if (!match || !match[1]) {
    return [];
  }
  // Split captured block into lines, trim, filter out empty ones, remove leading '-'
  return match[1]
    .split('\n')
    .map((line) => line.trim())
    .filter((line) => line.startsWith('-'))
    .map((line) => line.substring(1).trim())
    .filter((item) => item.length > 0);
}
